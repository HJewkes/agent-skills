#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEMPLATE_DIR="$SCRIPT_DIR/../templates"

# Color helpers
if [[ -t 1 ]] && command -v tput &>/dev/null; then
  RED=$(tput setaf 1)
  GREEN=$(tput setaf 2)
  YELLOW=$(tput setaf 3)
  BOLD=$(tput bold)
  RESET=$(tput sgr0)
else
  RED="" GREEN="" YELLOW="" BOLD="" RESET=""
fi

die() { echo "${RED}Error: $1${RESET}" >&2; exit 1; }
pass() { echo "  ${GREEN}[PASS]${RESET} $1"; }
warn() { echo "  ${YELLOW}[WARN]${RESET} $1"; }
fail() { echo "  ${RED}[FAIL]${RESET} $1"; }

usage() {
  cat <<'EOF'
Usage: repo-ci <command> [options]

Commands:
  init     Create a GitHub repo and fully configure it
  audit    Audit repository CI health against standards
  verify   Compare current audit against a baseline
  setup    Generate CI/CD workflow files from templates

Options:
  --help   Show this help message

Run 'repo-ci <command> --help' for command-specific options.

Exit codes:
  0  Success (audit: all checks pass)
  1  Error
  2  Warnings (audit: gaps found, setup: unsupported stack)
EOF
}

usage_audit() {
  cat <<'EOF'
Usage: repo-ci audit [options]

Audit repository CI health against standards.

Checks 7 areas:
  - CI workflow existence and jobs
  - Release workflow existence and jobs
  - Formatter configuration
  - Coverage configuration
  - Branch protection rulesets
  - Repo settings
  - Security scanning

Options:
  --json       Output results as JSON
  --scorecard  Output results as markdown table
  --help       Show this help message
EOF
}

usage_verify() {
  cat <<'EOF'
Usage: repo-ci verify --baseline <file> [options]

Compare current audit results against a saved baseline.

Save a baseline with: repo-ci audit --json > baseline.json
After making fixes, verify: repo-ci verify --baseline baseline.json

Options:
  --baseline <file>  Path to baseline JSON file (required)
  --help             Show this help message

Exit codes:
  0  No regressions (all areas same or improved)
  1  At least one area regressed
  2  No regressions but unchanged gaps remain
EOF
}

usage_setup() {
  cat <<'EOF'
Usage: repo-ci setup [options]

Generate CI/CD workflow files from templates.

Options:
  --dry-run          Print generated files to stdout without writing
  --preset <stack>   Stack preset: node or python (default: auto-detect)
  --help             Show this help message
EOF
}

usage_init() {
  cat <<'EOF'
Usage: repo-ci init [options]

Create a GitHub repository and fully configure it.

Creates the repo, configures settings (merge strategy, branch deletion,
wiki, discussions), sets up branch rulesets, generates CI/CD workflows,
and pushes the initial content.

Options:
  --private        Create as private repo (default: public)
  --preset <stack> Stack preset: node or python (default: auto-detect)
  --dry-run        Show what would happen without executing
  --skip-ci        Skip CI workflow generation
  --help           Show this help message
EOF
}

# --- Detection functions ---

detect_stack() {
  if [[ -f "package.json" ]]; then
    echo "node"
  elif [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]]; then
    echo "python"
  else
    echo "unknown"
  fi
}

detect_pkg_manager() {
  if [[ -f "pnpm-lock.yaml" ]]; then
    echo "pnpm"
  elif [[ -f "package-lock.json" ]]; then
    echo "npm"
  else
    echo "npm"
  fi
}

detect_test_framework() {
  local stack="$1"
  if [[ "$stack" == "node" ]] && [[ -f "package.json" ]]; then
    if grep -q '"vitest"' package.json 2>/dev/null; then
      echo "vitest"
      return
    fi
    if grep -q '"jest"' package.json 2>/dev/null; then
      echo "jest"
      return
    fi
  elif [[ "$stack" == "python" ]]; then
    if [[ -f "pyproject.toml" ]] && grep -q 'pytest' pyproject.toml 2>/dev/null; then
      echo "pytest"
      return
    fi
  fi
  echo "unknown"
}

# --- JSON helpers ---

escape_json() {
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' | awk '{printf "%s\\n", $0}' | sed '$ s/\\n$//'
}

# --- Status helpers ---

status_label() {
  local status="$1"
  case "$status" in
    pass) echo "PASS" ;;
    warn) echo "WARN" ;;
    fail) echo "FAIL" ;;
    *)    echo "$status" ;;
  esac
}

# --- Audit ---

audit_repo() {
  local json_output="$1"
  local scorecard_output="${2:-false}"
  local stack
  stack=$(detect_stack)

  local -a areas=()
  local -a statuses=()
  local -a details=()
  local -a recommendations=()
  local has_warnings=false

  # 1. CI workflow
  if [[ -f ".github/workflows/ci.yml" ]]; then
    local ci_content
    ci_content=$(cat .github/workflows/ci.yml)
    local ci_jobs=""
    local ci_missing=""
    for job in gitleaks security-audit lint test build; do
      if echo "$ci_content" | grep -q "^  ${job}:" 2>/dev/null; then
        ci_jobs="${ci_jobs:+$ci_jobs, }$job"
      else
        ci_missing="${ci_missing:+$ci_missing, }$job"
      fi
    done
    if [[ -z "$ci_missing" ]]; then
      areas+=("CI workflow")
      statuses+=("pass")
      details+=("All expected jobs present: $ci_jobs")
      recommendations+=("")
    else
      areas+=("CI workflow")
      statuses+=("warn")
      details+=("Missing jobs: $ci_missing")
      recommendations+=("Add missing jobs to .github/workflows/ci.yml")
      has_warnings=true
    fi
  else
    areas+=("CI workflow")
    statuses+=("fail")
    details+=("No .github/workflows/ci.yml found")
    recommendations+=("Run 'repo-ci setup' to generate CI workflow")
    has_warnings=true
  fi

  # 2. Release workflow
  if [[ -f ".github/workflows/release.yml" ]]; then
    local rel_content
    rel_content=$(cat .github/workflows/release.yml)
    local rel_jobs=""
    local rel_missing=""
    for job in validate publish github-release; do
      if echo "$rel_content" | grep -q "^  ${job}:" 2>/dev/null; then
        rel_jobs="${rel_jobs:+$rel_jobs, }$job"
      else
        rel_missing="${rel_missing:+$rel_missing, }$job"
      fi
    done
    if [[ -z "$rel_missing" ]]; then
      areas+=("Release workflow")
      statuses+=("pass")
      details+=("All expected jobs present: $rel_jobs")
      recommendations+=("")
    else
      areas+=("Release workflow")
      statuses+=("warn")
      details+=("Missing jobs: $rel_missing")
      recommendations+=("Add missing jobs to .github/workflows/release.yml")
      has_warnings=true
    fi
  else
    areas+=("Release workflow")
    statuses+=("fail")
    details+=("No .github/workflows/release.yml found")
    recommendations+=("Run 'repo-ci setup' to generate release workflow")
    has_warnings=true
  fi

  # 3. Formatter
  if [[ "$stack" == "node" ]]; then
    if [[ -f ".prettierrc" ]] || [[ -f ".prettierrc.json" ]] || [[ -f ".prettierrc.js" ]] || [[ -f "prettier.config.js" ]]; then
      areas+=("Formatter")
      statuses+=("pass")
      details+=("Prettier configuration found")
      recommendations+=("")
    else
      areas+=("Formatter")
      statuses+=("fail")
      details+=("No Prettier configuration found")
      recommendations+=("Add .prettierrc with project formatting rules")
      has_warnings=true
    fi
  elif [[ "$stack" == "python" ]]; then
    local has_ruff=false
    if [[ -f "ruff.toml" ]] || [[ -f ".ruff.toml" ]]; then
      has_ruff=true
    elif [[ -f "pyproject.toml" ]] && grep -q '\[tool\.ruff\]' pyproject.toml 2>/dev/null; then
      has_ruff=true
    fi
    if [[ "$has_ruff" == true ]]; then
      areas+=("Formatter")
      statuses+=("pass")
      details+=("Ruff configuration found")
      recommendations+=("")
    else
      areas+=("Formatter")
      statuses+=("fail")
      details+=("No ruff configuration found")
      recommendations+=("Add [tool.ruff] section to pyproject.toml")
      has_warnings=true
    fi
  else
    areas+=("Formatter")
    statuses+=("warn")
    details+=("Unknown stack; cannot check formatter")
    recommendations+=("Detect stack first")
    has_warnings=true
  fi

  # 4. Coverage
  local coverage_found=false
  if [[ "$stack" == "node" ]]; then
    for cfg in vitest.config.ts vitest.config.js jest.config.ts jest.config.js; do
      if [[ -f "$cfg" ]] && grep -q 'coverage' "$cfg" 2>/dev/null; then
        coverage_found=true
        break
      fi
    done
    if [[ "$coverage_found" == true ]]; then
      local has_thresholds=false
      for cfg in vitest.config.ts vitest.config.js jest.config.ts jest.config.js; do
        if [[ -f "$cfg" ]] && grep -q 'threshold' "$cfg" 2>/dev/null; then
          has_thresholds=true
          break
        fi
      done
      if [[ "$has_thresholds" == true ]]; then
        areas+=("Coverage")
        statuses+=("pass")
        details+=("Coverage with thresholds configured")
        recommendations+=("")
      else
        areas+=("Coverage")
        statuses+=("warn")
        details+=("Coverage enabled but no thresholds set")
        recommendations+=("Add coverage thresholds to test config")
        has_warnings=true
      fi
    else
      areas+=("Coverage")
      statuses+=("fail")
      details+=("No coverage configuration found")
      recommendations+=("Add coverage configuration to test config")
      has_warnings=true
    fi
  elif [[ "$stack" == "python" ]]; then
    if [[ -f "pyproject.toml" ]] && grep -q 'pytest' pyproject.toml 2>/dev/null && grep -q 'cov' pyproject.toml 2>/dev/null; then
      coverage_found=true
    elif [[ -f "setup.cfg" ]] && grep -q 'cov' setup.cfg 2>/dev/null; then
      coverage_found=true
    fi
    if [[ "$coverage_found" == true ]]; then
      areas+=("Coverage")
      statuses+=("pass")
      details+=("Coverage configuration found")
      recommendations+=("")
    else
      areas+=("Coverage")
      statuses+=("warn")
      details+=("No coverage configuration detected")
      recommendations+=("Add pytest-cov configuration to pyproject.toml")
      has_warnings=true
    fi
  else
    areas+=("Coverage")
    statuses+=("warn")
    details+=("Unknown stack; cannot check coverage")
    recommendations+=("Detect stack first")
    has_warnings=true
  fi

  # 5. Branch protection
  local gh_authenticated=false
  if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
    gh_authenticated=true
  fi
  if [[ "$gh_authenticated" == true ]]; then
    local repo_slug
    repo_slug=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || echo "")
    if [[ -n "$repo_slug" ]]; then
      local is_private
      is_private=$(gh repo view --json isPrivate -q '.isPrivate' 2>/dev/null || echo "false")
      local rulesets
      rulesets=$(gh api "repos/$repo_slug/rulesets" 2>/dev/null || echo "[]")
      local ruleset_count
      ruleset_count=$(echo "$rulesets" | grep -c '"id"' 2>/dev/null || true)
      ruleset_count="${ruleset_count:-0}"
      ruleset_count="${ruleset_count//[^0-9]/}"

      if [[ "$ruleset_count" -eq 0 ]]; then
        if [[ "$is_private" == "true" ]]; then
          areas+=("Branch protection")
          statuses+=("warn")
          details+=("No rulesets (private repo — requires GitHub Pro/Team)")
          recommendations+=("Upgrade plan or make repo public, then run 'repo-ci init'")
          has_warnings=true
        else
          areas+=("Branch protection")
          statuses+=("fail")
          details+=("No branch rulesets configured")
          recommendations+=("Run 'repo-ci init' or 'repo-ci setup' with rulesets enabled")
          has_warnings=true
        fi
      else
        # Validate first ruleset content
        local first_id
        first_id=$(echo "$rulesets" | grep -o '"id":[0-9]*' | head -1 | grep -o '[0-9]*')
        local ruleset_detail
        ruleset_detail=$(gh api "repos/$repo_slug/rulesets/$first_id" 2>/dev/null || echo "{}")

        local bp_issues=""
        if ! echo "$ruleset_detail" | grep -q '"type":"pull_request"' 2>/dev/null; then
          bp_issues="${bp_issues:+$bp_issues; }missing pull_request rule"
        fi
        if ! echo "$ruleset_detail" | grep -q '"type":"deletion"' 2>/dev/null; then
          bp_issues="${bp_issues:+$bp_issues; }missing deletion rule"
        fi
        if ! echo "$ruleset_detail" | grep -q '"type":"non_fast_forward"' 2>/dev/null; then
          bp_issues="${bp_issues:+$bp_issues; }missing non_fast_forward rule"
        fi
        if ! echo "$ruleset_detail" | grep -q '"bypass_actors":\[' 2>/dev/null || echo "$ruleset_detail" | grep -q '"bypass_actors":\[\]' 2>/dev/null; then
          bp_issues="${bp_issues:+$bp_issues; }no bypass actors configured"
        fi

        if [[ -z "$bp_issues" ]]; then
          areas+=("Branch protection")
          statuses+=("pass")
          details+=("$ruleset_count ruleset(s) with correct rules and bypass actors")
          recommendations+=("")
        else
          areas+=("Branch protection")
          statuses+=("warn")
          details+=("$ruleset_count ruleset(s) but: $bp_issues")
          recommendations+=("Update ruleset to include all standard rules and bypass actors")
          has_warnings=true
        fi
      fi
    else
      areas+=("Branch protection")
      statuses+=("warn")
      details+=("Not in a GitHub repository")
      recommendations+=("Run from a cloned GitHub repository")
      has_warnings=true
    fi
  else
    areas+=("Branch protection")
    statuses+=("warn")
    details+=("gh CLI not authenticated; skipping check")
    recommendations+=("Run 'gh auth login' to enable this check")
    has_warnings=true
  fi

  # 6. Repo settings
  if [[ "$gh_authenticated" == true ]] && [[ -n "$repo_slug" ]]; then
    local repo_json
    repo_json=$(gh api "repos/$repo_slug" --jq '{
      allow_squash_merge: .allow_squash_merge,
      allow_merge_commit: .allow_merge_commit,
      allow_rebase_merge: .allow_rebase_merge,
      delete_branch_on_merge: .delete_branch_on_merge,
      has_wiki: .has_wiki,
      has_discussions: .has_discussions
    }' 2>/dev/null || echo "{}")

    local settings_issues=""
    if echo "$repo_json" | grep -q '"allow_merge_commit": true' 2>/dev/null; then
      settings_issues="${settings_issues:+$settings_issues; }merge commits allowed"
    fi
    if echo "$repo_json" | grep -q '"delete_branch_on_merge": false' 2>/dev/null; then
      settings_issues="${settings_issues:+$settings_issues; }delete-branch-on-merge disabled"
    fi
    if echo "$repo_json" | grep -q '"has_wiki": false' 2>/dev/null; then
      settings_issues="${settings_issues:+$settings_issues; }wiki disabled"
    fi
    if echo "$repo_json" | grep -q '"has_discussions": false' 2>/dev/null; then
      settings_issues="${settings_issues:+$settings_issues; }discussions disabled"
    fi
    if echo "$repo_json" | grep -q '"allow_squash_merge": false' 2>/dev/null; then
      settings_issues="${settings_issues:+$settings_issues; }squash merge disabled"
    fi
    if echo "$repo_json" | grep -q '"allow_rebase_merge": false' 2>/dev/null; then
      settings_issues="${settings_issues:+$settings_issues; }rebase merge disabled"
    fi

    if [[ -z "$settings_issues" ]]; then
      areas+=("Repo settings")
      statuses+=("pass")
      details+=("All repo settings match standard")
      recommendations+=("")
    else
      areas+=("Repo settings")
      statuses+=("warn")
      details+=("$settings_issues")
      recommendations+=("Run 'repo-ci init' or configure manually via GitHub settings")
      has_warnings=true
    fi
  elif [[ "$gh_authenticated" == true ]]; then
    areas+=("Repo settings")
    statuses+=("warn")
    details+=("Not in a GitHub repository")
    recommendations+=("Run from a cloned GitHub repository")
    has_warnings=true
  else
    areas+=("Repo settings")
    statuses+=("warn")
    details+=("gh CLI not authenticated; skipping check")
    recommendations+=("Run 'gh auth login' to enable this check")
    has_warnings=true
  fi

  # 7. Security scanning
  if [[ -f ".github/workflows/ci.yml" ]]; then
    local ci_sec
    ci_sec=$(cat .github/workflows/ci.yml)
    local has_gitleaks=false
    local has_audit=false
    if echo "$ci_sec" | grep -q 'gitleaks' 2>/dev/null; then
      has_gitleaks=true
    fi
    if echo "$ci_sec" | grep -q 'security-audit\|npm audit\|pip-audit' 2>/dev/null; then
      has_audit=true
    fi
    if [[ "$has_gitleaks" == true ]] && [[ "$has_audit" == true ]]; then
      areas+=("Security scanning")
      statuses+=("pass")
      details+=("Gitleaks and dependency audit configured")
      recommendations+=("")
    elif [[ "$has_gitleaks" == true ]] || [[ "$has_audit" == true ]]; then
      areas+=("Security scanning")
      statuses+=("warn")
      local sec_detail=""
      [[ "$has_gitleaks" == false ]] && sec_detail="Missing gitleaks"
      [[ "$has_audit" == false ]] && sec_detail="${sec_detail:+$sec_detail; }Missing dependency audit"
      details+=("$sec_detail")
      recommendations+=("Add missing security scanning jobs")
      has_warnings=true
    else
      areas+=("Security scanning")
      statuses+=("fail")
      details+=("No security scanning found in CI")
      recommendations+=("Add gitleaks and dependency audit jobs")
      has_warnings=true
    fi
  else
    areas+=("Security scanning")
    statuses+=("fail")
    details+=("No CI workflow to check")
    recommendations+=("Run 'repo-ci setup' to generate CI workflow")
    has_warnings=true
  fi

  # Output
  if [[ "$json_output" == true ]]; then
    echo "{"
    echo "  \"stack\": \"$stack\","
    echo "  \"areas\": ["
    for i in "${!areas[@]}"; do
      local comma=""
      [[ $i -lt $(( ${#areas[@]} - 1 )) ]] && comma=","
      echo "    {"
      echo "      \"name\": \"$(escape_json "${areas[$i]}")\","
      echo "      \"status\": \"${statuses[$i]}\","
      echo "      \"details\": \"$(escape_json "${details[$i]}")\","
      echo "      \"recommendation\": \"$(escape_json "${recommendations[$i]}")\""
      echo "    }$comma"
    done
    echo "  ]"
    echo "}"
  elif [[ "$scorecard_output" == true ]]; then
    local pass_count=0 warn_count=0 fail_count=0
    echo "## CI Health Scorecard"
    echo ""
    echo "| Area | Status | Details |"
    echo "|------|--------|---------|"
    for i in "${!areas[@]}"; do
      local label
      label=$(status_label "${statuses[$i]}")
      echo "| ${areas[$i]} | $label | ${details[$i]} |"
      case "${statuses[$i]}" in
        pass) pass_count=$(( pass_count + 1 )) ;;
        warn) warn_count=$(( warn_count + 1 )) ;;
        fail) fail_count=$(( fail_count + 1 )) ;;
      esac
    done
    echo ""
    echo "**Result: $pass_count PASS, $warn_count WARN, $fail_count FAIL**"
  else
    echo "${BOLD}CI Health Audit${RESET} (stack: $stack)"
    echo ""
    for i in "${!areas[@]}"; do
      case "${statuses[$i]}" in
        pass) pass "${areas[$i]}: ${details[$i]}" ;;
        warn) warn "${areas[$i]}: ${details[$i]}" ;;
        fail) fail "${areas[$i]}: ${details[$i]}" ;;
      esac
    done
    echo ""
    # Print recommendations for non-pass items
    local has_recs=false
    for i in "${!areas[@]}"; do
      if [[ "${statuses[$i]}" != "pass" ]] && [[ -n "${recommendations[$i]}" ]]; then
        if [[ "$has_recs" == false ]]; then
          echo "${BOLD}Recommendations:${RESET}"
          has_recs=true
        fi
        echo "  - ${recommendations[$i]}"
      fi
    done
  fi

  if [[ "$has_warnings" == true ]]; then
    return 2
  fi
  return 0
}

# --- Verify ---

verify_baseline() {
  local baseline_file="$1"

  if [[ ! -f "$baseline_file" ]]; then
    die "Baseline file not found: $baseline_file"
  fi

  if ! command -v python3 &>/dev/null; then
    die "python3 is required for JSON parsing"
  fi

  # Run fresh audit as JSON
  local current_file
  current_file=$(mktemp)
  audit_repo true false > "$current_file" 2>/dev/null || true

  # Compare using python3 with file paths
  python3 - "$baseline_file" "$current_file" <<'PYEOF'
import json, sys

with open(sys.argv[1]) as f:
    baseline = json.load(f)
with open(sys.argv[2]) as f:
    current = json.load(f)

base_areas = {a['name']: a['status'] for a in baseline['areas']}
curr_areas = {a['name']: a['status'] for a in current['areas']}

rank = {'pass': 2, 'warn': 1, 'fail': 0}
all_names = list(dict.fromkeys(list(base_areas.keys()) + list(curr_areas.keys())))

fixed = 0
regressed = 0
remaining = 0

rows = []
for name in all_names:
    before = base_areas.get(name, 'n/a')
    after = curr_areas.get(name, 'n/a')
    b_rank = rank.get(before, -1)
    a_rank = rank.get(after, -1)
    if a_rank > b_rank:
        change = 'FIXED'
        fixed += 1
    elif a_rank < b_rank:
        change = 'REGRESSED'
        regressed += 1
    elif after != 'pass':
        change = '\u2014'
        remaining += 1
    else:
        continue
    rows.append((name, before.upper(), after.upper(), change))

print('## Verification Report')
print()
print('| Area | Before | After | Change |')
print('|------|--------|-------|--------|')
for name, before, after, change in rows:
    print(f'| {name} | {before} | {after} | {change} |')
print()
print(f'**{fixed} fixed, {regressed} regressed, {remaining} remaining**')

if regressed > 0:
    sys.exit(1)
elif remaining > 0:
    sys.exit(2)
else:
    sys.exit(0)
PYEOF
  local verify_exit=$?
  rm -f "$current_file"
  return "$verify_exit"
}

# --- Post-setup npm script check ---

check_npm_scripts() {
  local stack="$1"

  if [[ "$stack" != "node" ]]; then
    return 0
  fi

  if [[ ! -f "package.json" ]]; then
    return 0
  fi

  local required_scripts=("test" "format:check" "test:coverage")
  local check_icon_pass check_icon_fail

  if [[ -t 1 ]] && command -v tput &>/dev/null; then
    check_icon_pass="${GREEN}✓${RESET}"
    check_icon_fail="${RED}✗${RESET}"
  else
    check_icon_pass="OK"
    check_icon_fail="MISSING"
  fi

  echo ""
  echo "Post-setup check:"
  local has_missing=false
  for script_name in "${required_scripts[@]}"; do
    if python3 -c "
import json, sys
pkg = json.load(open('package.json'))
scripts = pkg.get('scripts', {})
sys.exit(0 if '$script_name' in scripts else 1)
" 2>/dev/null; then
      echo "  $check_icon_pass npm script '$script_name' found"
    else
      has_missing=true
      local hint=""
      case "$script_name" in
        "format:check") hint=" — CI will fail without it" ;;
        "test:coverage") hint=" — coverage job will fail" ;;
      esac
      echo "  $check_icon_fail npm script '$script_name' not found${hint}"
    fi
  done

  if [[ "$has_missing" == true ]]; then
    return 2
  fi
  return 0
}

# --- Setup ---

prompt_or_default() {
  local prompt_text="$1"
  local default_val="$2"
  if [[ -t 0 ]]; then
    local input
    read -rp "${prompt_text} [${default_val}]: " input
    echo "${input:-$default_val}"
  else
    echo "$default_val"
  fi
}

expand_template() {
  local template_file="$1"
  shift
  local content
  content=$(cat "$template_file")
  while [[ $# -gt 0 ]]; do
    local key="$1"
    local val="$2"
    # shellcheck disable=SC2001  # nested braces make parameter expansion awkward
    content=$(echo "$content" | sed "s|{{${key}}}|${val}|g")
    shift 2
  done
  echo "$content"
}

setup_repo() {
  local dry_run="$1"
  local preset="$2"

  local stack
  if [[ -n "$preset" ]]; then
    stack="$preset"
  else
    stack=$(detect_stack)
  fi

  if [[ "$stack" == "unknown" ]]; then
    echo "${YELLOW}Unsupported stack.${RESET}" >&2
    echo "Could not detect project type (no package.json, pyproject.toml, or setup.py)." >&2
    echo "Supported stacks: node, python" >&2
    echo "Use --preset to specify the stack manually." >&2
    exit 2
  fi

  local template_path="$TEMPLATE_DIR/$stack"
  if [[ ! -d "$template_path" ]]; then
    die "Template directory not found: $template_path"
  fi

  local created_files=()

  if [[ "$stack" == "node" ]]; then
    local node_version pkg_manager test_framework
    local build_output

    node_version=$(prompt_or_default "Node version" "22")
    pkg_manager=$(detect_pkg_manager)
    test_framework=$(detect_test_framework "$stack")

    local install_cmd="npm ci"
    [[ "$pkg_manager" == "pnpm" ]] && install_cmd="pnpm install --frozen-lockfile"

    local test_coverage_cmd="npx vitest run --coverage"
    [[ "$test_framework" == "jest" ]] && test_coverage_cmd="npx jest --coverage"

    local build_cmd="npm run build"
    build_output=$(prompt_or_default "Build output path" "dist/cli.js")

    local publish_cmd="npm publish --provenance --access public"

    local enable_rulesets
    enable_rulesets=$(prompt_or_default "Create branch rulesets" "yes")

    # Expand CI template
    local ci_content
    ci_content=$(expand_template "$template_path/ci.yml" \
      "NODE_VERSION" "$node_version" \
      "PKG_MANAGER" "$pkg_manager" \
      "INSTALL_CMD" "$install_cmd" \
      "TEST_COVERAGE_CMD" "$test_coverage_cmd" \
      "BUILD_CMD" "$build_cmd" \
      "BUILD_OUTPUT" "$build_output")

    # Expand release template
    local release_content
    release_content=$(expand_template "$template_path/release.yml" \
      "NODE_VERSION" "$node_version" \
      "PKG_MANAGER" "$pkg_manager" \
      "INSTALL_CMD" "$install_cmd" \
      "BUILD_CMD" "$build_cmd" \
      "PUBLISH_CMD" "$publish_cmd")

    if [[ "$dry_run" == true ]]; then
      echo "--- .github/workflows/ci.yml ---"
      echo "$ci_content"
      echo ""
      echo "--- .github/workflows/release.yml ---"
      echo "$release_content"
    else
      mkdir -p .github/workflows
      echo "$ci_content" > .github/workflows/ci.yml
      created_files+=(".github/workflows/ci.yml")
      echo "$release_content" > .github/workflows/release.yml
      created_files+=(".github/workflows/release.yml")
    fi

    # Repo settings and branch rulesets
    if [[ "$dry_run" != true ]]; then
      configure_repo_settings
      if [[ "$enable_rulesets" == "yes" ]]; then
        setup_rulesets
      fi
    fi

  elif [[ "$stack" == "python" ]]; then
    local python_version
    python_version=$(prompt_or_default "Python version" "3.12")

    local enable_rulesets
    enable_rulesets=$(prompt_or_default "Create branch rulesets" "yes")

    # Expand CI template
    local ci_content
    ci_content=$(expand_template "$template_path/ci.yml" \
      "PYTHON_VERSION" "$python_version")

    # Expand release template
    local release_content
    release_content=$(expand_template "$template_path/release.yml" \
      "PYTHON_VERSION" "$python_version")

    if [[ "$dry_run" == true ]]; then
      echo "--- .github/workflows/ci.yml ---"
      echo "$ci_content"
      echo ""
      echo "--- .github/workflows/release.yml ---"
      echo "$release_content"
    else
      mkdir -p .github/workflows
      echo "$ci_content" > .github/workflows/ci.yml
      created_files+=(".github/workflows/ci.yml")
      echo "$release_content" > .github/workflows/release.yml
      created_files+=(".github/workflows/release.yml")
    fi

    # Repo settings and branch rulesets
    if [[ "$dry_run" != true ]]; then
      configure_repo_settings
      if [[ "$enable_rulesets" == "yes" ]]; then
        setup_rulesets
      fi
    fi
  fi

  if [[ "$dry_run" != true ]] && [[ ${#created_files[@]} -gt 0 ]]; then
    echo ""
    echo "${BOLD}Setup complete.${RESET} Created files:"
    for f in "${created_files[@]}"; do
      echo "  - $f"
    done
    check_npm_scripts "$stack" || true
  fi
}

configure_repo_settings() {
  if ! command -v gh &>/dev/null || ! gh auth status &>/dev/null 2>&1; then
    echo "${YELLOW}gh CLI not authenticated; skipping repo settings.${RESET}" >&2
    return 0
  fi

  local repo_slug
  repo_slug=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || echo "")
  if [[ -z "$repo_slug" ]]; then
    echo "${YELLOW}Not in a GitHub repository; skipping repo settings.${RESET}" >&2
    return 0
  fi

  local settings_payload
  settings_payload=$(cat <<'ENDJSON'
{
  "allow_squash_merge": true,
  "allow_merge_commit": false,
  "allow_rebase_merge": true,
  "delete_branch_on_merge": true,
  "has_wiki": true,
  "has_discussions": true,
  "squash_merge_commit_title": "COMMIT_OR_PR_TITLE",
  "squash_merge_commit_message": "COMMIT_MESSAGES"
}
ENDJSON
)

  if gh api "repos/$repo_slug" --method PATCH --input - <<< "$settings_payload" &>/dev/null; then
    echo "  ${GREEN}Configured repo settings (squash+rebase, delete branch on merge, wiki, discussions)${RESET}"
  else
    echo "  ${YELLOW}Failed to configure repo settings${RESET}" >&2
  fi
}

setup_rulesets() {
  if ! command -v gh &>/dev/null || ! gh auth status &>/dev/null 2>&1; then
    echo "${YELLOW}gh CLI not authenticated; skipping ruleset creation.${RESET}" >&2
    return 0
  fi

  local repo_slug
  repo_slug=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || echo "")
  if [[ -z "$repo_slug" ]]; then
    echo "${YELLOW}Not in a GitHub repository; skipping ruleset creation.${RESET}" >&2
    return 0
  fi

  local is_private
  is_private=$(gh repo view --json isPrivate -q '.isPrivate' 2>/dev/null || echo "false")
  if [[ "$is_private" == "true" ]]; then
    echo "${YELLOW}Private repo detected — rulesets require GitHub Pro/Team. Skipping.${RESET}" >&2
    return 0
  fi

  local default_branch
  default_branch=$(gh repo view --json defaultBranchRef -q '.defaultBranchRef.name' 2>/dev/null || echo "main")

  local ruleset_payload
  ruleset_payload=$(cat <<ENDJSON
{
  "name": "Protect $default_branch",
  "target": "branch",
  "enforcement": "active",
  "bypass_actors": [
    {"actor_id": 5, "actor_type": "RepositoryRole", "bypass_mode": "always"}
  ],
  "conditions": {
    "ref_name": {
      "include": ["refs/heads/$default_branch"],
      "exclude": []
    }
  },
  "rules": [
    {
      "type": "pull_request",
      "parameters": {
        "allowed_merge_methods": ["squash", "rebase"],
        "dismiss_stale_reviews_on_push": false,
        "require_code_owner_review": false,
        "require_last_push_approval": false,
        "required_approving_review_count": 1,
        "required_review_thread_resolution": false,
        "required_reviewers": []
      }
    },
    {"type": "deletion"},
    {"type": "non_fast_forward"}
  ]
}
ENDJSON
)

  if gh api "repos/$repo_slug/rulesets" --method POST --input - <<< "$ruleset_payload" &>/dev/null; then
    echo "  ${GREEN}Created branch ruleset for $default_branch${RESET}"
  else
    echo "  ${YELLOW}Failed to create branch ruleset (may require admin permissions or GitHub Pro for private repos)${RESET}" >&2
  fi
}

# --- Init ---

init_repo() {
  local dry_run="$1"
  local preset="$2"
  local visibility="$3"
  local skip_ci="$4"

  local stack
  if [[ -n "$preset" ]]; then
    stack="$preset"
  else
    stack=$(detect_stack)
  fi

  # Verify we have a git repo locally
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    die "Not inside a git repository. Run 'git init' first."
  fi

  # Check for at least one commit
  if ! git rev-parse HEAD &>/dev/null 2>&1; then
    die "No commits yet. Make an initial commit first."
  fi

  local repo_name
  repo_name=$(basename "$(git rev-parse --show-toplevel)")

  if [[ "$dry_run" == true ]]; then
    echo "${BOLD}repo-ci init (dry run)${RESET}"
    echo ""
    echo "Would create GitHub repo: $repo_name ($visibility)"
    echo "Would configure repo settings:"
    echo "  - allow_squash_merge: true"
    echo "  - allow_merge_commit: false"
    echo "  - allow_rebase_merge: true"
    echo "  - delete_branch_on_merge: true"
    echo "  - has_wiki: true"
    echo "  - has_discussions: true"
    echo "Would create branch ruleset (protect default branch)"
    if [[ "$visibility" == "private" ]]; then
      echo "  ${YELLOW}Note: Rulesets require GitHub Pro/Team for private repos${RESET}"
    fi
    if [[ "$skip_ci" != true ]]; then
      echo "Would generate CI/CD workflows (stack: $stack)"
      echo ""
      setup_repo true "$preset"
    else
      echo "Skipping CI workflow generation (--skip-ci)"
    fi
    return 0
  fi

  # Create the GitHub repo
  echo "${BOLD}Creating GitHub repository...${RESET}"
  local gh_create_args=(gh repo create "$repo_name" "--$visibility" --source . --push)
  if ! "${gh_create_args[@]}"; then
    die "Failed to create GitHub repository"
  fi

  # Ensure default branch is main
  local default_branch
  default_branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "main")
  if [[ "$default_branch" != "main" ]]; then
    echo "Renaming default branch from $default_branch to main..."
    git branch -m "$default_branch" main
    git push origin main
    gh repo edit --default-branch main
  fi

  # Configure settings
  echo ""
  echo "${BOLD}Configuring repo settings...${RESET}"
  configure_repo_settings

  # Create rulesets
  echo ""
  echo "${BOLD}Setting up branch protection...${RESET}"
  setup_rulesets

  # Generate CI workflows
  if [[ "$skip_ci" != true ]]; then
    echo ""
    echo "${BOLD}Generating CI/CD workflows...${RESET}"
    setup_repo false "$preset"

    # Push workflow files
    if [[ -f ".github/workflows/ci.yml" ]]; then
      git add .github/workflows/
      git commit -m "Add CI/CD workflows"
      git push origin main
    fi
  fi

  echo ""
  echo "${BOLD}${GREEN}Repository initialized successfully!${RESET}"
  local repo_slug
  repo_slug=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || echo "")
  if [[ -n "$repo_slug" ]]; then
    echo "  https://github.com/$repo_slug"
  fi
}

# --- Main argument parsing ---

if [[ $# -eq 0 ]]; then
  usage
  exit 1
fi

COMMAND="$1"
shift

case "$COMMAND" in
  init)
    DRY_RUN=false
    PRESET=""
    VISIBILITY="public"
    SKIP_CI=false
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --dry-run) DRY_RUN=true; shift ;;
        --private) VISIBILITY="private"; shift ;;
        --preset) PRESET="$2"; shift 2 ;;
        --skip-ci) SKIP_CI=true; shift ;;
        --help) usage_init; exit 0 ;;
        *) die "Unknown option for init: $1" ;;
      esac
    done
    init_repo "$DRY_RUN" "$PRESET" "$VISIBILITY" "$SKIP_CI"
    ;;
  audit)
    JSON_OUTPUT=false
    SCORECARD_OUTPUT=false
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) JSON_OUTPUT=true; shift ;;
        --scorecard) SCORECARD_OUTPUT=true; shift ;;
        --help) usage_audit; exit 0 ;;
        *) die "Unknown option for audit: $1" ;;
      esac
    done
    if [[ "$JSON_OUTPUT" == true ]] && [[ "$SCORECARD_OUTPUT" == true ]]; then
      die "--json and --scorecard are mutually exclusive"
    fi
    audit_repo "$JSON_OUTPUT" "$SCORECARD_OUTPUT"
    ;;
  verify)
    BASELINE=""
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --baseline) BASELINE="$2"; shift 2 ;;
        --help) usage_verify; exit 0 ;;
        *) die "Unknown option for verify: $1" ;;
      esac
    done
    if [[ -z "$BASELINE" ]]; then
      die "Missing required option: --baseline <file>"
    fi
    verify_baseline "$BASELINE"
    ;;
  setup)
    DRY_RUN=false
    PRESET=""
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --dry-run) DRY_RUN=true; shift ;;
        --preset) PRESET="$2"; shift 2 ;;
        --help) usage_setup; exit 0 ;;
        *) die "Unknown option for setup: $1" ;;
      esac
    done
    setup_repo "$DRY_RUN" "$PRESET"
    ;;
  --help) usage; exit 0 ;;
  *) die "Unknown command: $COMMAND. Run 'repo-ci --help' for usage." ;;
esac
