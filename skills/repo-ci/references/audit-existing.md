# Audit Existing Repo

Agent guide for `repo-ci` audit mode. Follow these steps in order.

## Step 1: Run the Audit

In the target repo directory, run the scorecard to get a formatted health report:

```bash
repo-ci audit --scorecard
```

For machine-readable output, use `--json` instead. Exit code 0 = all checks pass; exit code 2 = gaps found; exit code 1 = error.

## Step 2: Interpret Results

The scorecard shows 6 areas with PASS, WARN, or FAIL status. The areas checked are: CI workflow, Release workflow, Formatter, Coverage, Branch protection, Security scanning.

## Step 3: Detail Gaps

For each WARN or FAIL area, explain:

1. **What's missing** — repeat the Details column from the scorecard
2. **Why it matters** — reference the relevant section in [standards.md](standards.md)
3. **Specific fix** — the concrete action needed (e.g., add a job, create a file, enable a ruleset)

Reference guide for common gaps:

| Area | Common gap | Standards section |
|------|------------|-------------------|
| CI workflow | Missing gitleaks job or coverage upload | Universal Standards, Node/TypeScript CI Jobs |
| Release workflow | Missing version-verify step or provenance flag | Node/TypeScript Release Pipeline |
| Formatter | No Prettier config or missing `format:check` script | Node/TypeScript CI Jobs |
| Coverage | No thresholds set in vitest.config.ts | Coverage Thresholds |
| Branch protection | Rulesets not configured | Universal Standards |
| Security scanning | gitleaks not in CI | Universal Standards |

## Step 4: Handle Custom CI

Before flagging a gap, check whether the repo uses non-standard but functional CI:
- If `.github/workflows/` contains files not generated by `repo-ci`, read them first
- A custom workflow that achieves the same result (e.g., uses a different secret scanner) is not a gap
- Only flag areas where the function is genuinely absent, not just implemented differently
- Note any custom patterns so the user knows they won't be overwritten

## Step 5: Offer to Fix

If any WARN or FAIL areas were found, offer:

> "I can run `repo-ci setup` to generate the missing pieces. Want me to preview what it will create first with `--dry-run`?"

If the user agrees, proceed to [setup-new.md](setup-new.md) setup flow.

## Step 6: Post-Fix Verification

After making fixes, verify improvements against a saved baseline:

```bash
# Save baseline before fixing
repo-ci audit --json > baseline.json

# Make fixes, then verify
repo-ci verify --baseline baseline.json
```

The verify command compares each area's status and reports what improved, what regressed, and what remains. Exit code 0 = no regressions, 1 = regressions found, 2 = unchanged gaps remain.

If any areas still fail, explain why (e.g., branch protection rulesets must be configured in GitHub UI and cannot be auto-fixed by the script).
