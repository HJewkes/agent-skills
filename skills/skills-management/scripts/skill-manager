#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage: skill-manager <command> [options]

Manage agentic skills in the agent-skills repository.

Commands:
  create <name>                Scaffold a new skill
  install <owner/repo> [opts]  Install skill from GitHub (delegates to skills-cli)
  remove <name>                Remove a skill from the repo
  list [--json]                List all skills with status
  validate [<name>]            Validate skill conventions

Options:
  --help    Show this help message

Exit codes:
  0  Success
  1  Error
  2  Warnings found (validate only)
EOF
}

# ── Constants ─────────────────────────────────────────────────────

# Resolve repo root relative to this script's location
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"
SKILLS_DIR="$REPO_ROOT/skills"
MANIFEST="$REPO_ROOT/skill-manifest.json"

# ── Helpers ───────────────────────────────────────────────────────

die() { echo "Error: $1" >&2; exit 1; }

is_kebab_case() {
  [[ "$1" =~ ^[a-z0-9]([a-z0-9-]*[a-z0-9])?$ ]]
}

kebab_to_title() {
  echo "$1" | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)}1'
}

skill_exists() {
  [[ -d "$SKILLS_DIR/$1" ]]
}

# ── Commands ──────────────────────────────────────────────────────

cmd_create() {
  local name="" script_name="" dry_run=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --script) script_name="$2"; shift 2 ;;
      --dry-run) dry_run=true; shift ;;
      --help) cat <<'EOF'
Usage: skill-manager create <name> [--script <name>] [--dry-run]

Scaffold a new skill in the agent-skills repo.

Options:
  --script <name>  Also scaffold a script in scripts/
  --dry-run        Show what would be created without writing
EOF
        exit 0 ;;
      -*) die "Unknown option: $1" ;;
      *) name="$1"; shift ;;
    esac
  done

  [[ -n "$name" ]] || die "Skill name required. Usage: skill-manager create <name>"
  is_kebab_case "$name" || die "Name must be kebab-case (lowercase letters, numbers, hyphens): $name"
  skill_exists "$name" && die "Skill already exists: $name"

  local title
  title="$(kebab_to_title "$name")"

  local files=("$SKILLS_DIR/$name/SKILL.md")
  [[ -n "$script_name" ]] && files+=("$SKILLS_DIR/$name/scripts/$script_name")

  if [[ "$dry_run" == true ]]; then
    echo "Would create:"
    for f in "${files[@]}"; do
      echo "  ${f#"$REPO_ROOT"/}"
    done
    exit 0
  fi

  mkdir -p "$SKILLS_DIR/$name"

  cat > "$SKILLS_DIR/$name/SKILL.md" <<SKILL
---
name: $name
description: Use when
---

# $title
SKILL

  if [[ -n "$script_name" ]]; then
    is_kebab_case "$script_name" || die "Script name must be kebab-case: $script_name"
    mkdir -p "$SKILLS_DIR/$name/scripts"
    cat > "$SKILLS_DIR/$name/scripts/$script_name" <<SCRIPT
#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: $script_name [--help]

Description here.

Options:
  --help    Show this help message

Exit codes:
  0  Success
  1  Error
USAGE
}

while [[ \$# -gt 0 ]]; do
  case "\$1" in
    --help) usage; exit 0 ;;
    *) echo "Unknown option: \$1" >&2; usage >&2; exit 1 ;;
  esac
done
SCRIPT
    chmod +x "$SKILLS_DIR/$name/scripts/$script_name"
  fi

  # Add to manifest if jq available
  if [[ -f "$MANIFEST" ]] && command -v jq &>/dev/null; then
    local tmp
    tmp=$(mktemp)
    jq --arg name "$name" \
       '.skills[$name] = { "type": "original" }' \
       "$MANIFEST" > "$tmp" && mv "$tmp" "$MANIFEST"
  fi

  echo "Created skill: $name" >&2
  echo "$SKILLS_DIR/$name/SKILL.md"
}

cmd_install() {
  # Delegate to skills-cli
  if ! command -v npx &>/dev/null; then
    die "npx not found. Install Node.js to use skills-cli."
  fi

  echo "Delegating to skills-cli..." >&2
  exec npx skills add "$@"
}

cmd_remove() {
  local name="" dry_run=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run) dry_run=true; shift ;;
      --help) cat <<'EOF'
Usage: skill-manager remove <name> [--dry-run]

Remove a skill from the agent-skills repo.

Options:
  --dry-run    Show what would be removed without deleting
EOF
        exit 0 ;;
      -*) die "Unknown option: $1" ;;
      *) name="$1"; shift ;;
    esac
  done

  [[ -n "$name" ]] || die "Skill name required. Usage: skill-manager remove <name>"
  skill_exists "$name" || die "Skill not found: $name"

  if [[ "$dry_run" == true ]]; then
    echo "Would remove:"
    echo "  skills/$name/"
    [[ -f "$MANIFEST" ]] && echo "  skill-manifest.json entry: $name"
    exit 0
  fi

  rm -rf "${SKILLS_DIR:?}/${name:?}"

  # Remove from manifest
  if [[ -f "$MANIFEST" ]] && command -v jq &>/dev/null; then
    local tmp
    tmp=$(mktemp)
    jq --arg name "$name" 'del(.skills[$name])' "$MANIFEST" > "$tmp" && mv "$tmp" "$MANIFEST"
  fi

  echo "Removed: $name" >&2
}

cmd_list() {
  local json=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) json=true; shift ;;
      --help) cat <<'EOF'
Usage: skill-manager list [--json]

List all skills in the repo.

Options:
  --json    Output as JSON
EOF
        exit 0 ;;
      -*) die "Unknown option: $1" ;;
      *) die "Unknown argument: $1" ;;
    esac
  done

  if [[ "$json" == true ]]; then
    _list_json
  else
    _list_table
  fi
}

_list_table() {
  printf "%-40s %-10s %-6s %-20s\n" "SKILL" "TYPE" "SCRIPT" "SOURCE"
  printf "%-40s %-10s %-6s %-20s\n" "-----" "----" "------" "------"

  for skill_dir in "$SKILLS_DIR"/*/; do
    [[ -d "$skill_dir" ]] || continue
    local name
    name=$(basename "$skill_dir")
    [[ "$name" == _* || "$name" == .* ]] && continue

    local skill_type="original" has_script="no" source="-"

    # Check manifest for provenance
    if [[ -f "$MANIFEST" ]] && command -v jq &>/dev/null; then
      skill_type=$(jq -r ".skills[\"$name\"].type // \"unknown\"" "$MANIFEST" 2>/dev/null)
      local upstream
      upstream=$(jq -r ".skills[\"$name\"].upstream // empty" "$MANIFEST" 2>/dev/null)
      [[ -n "$upstream" ]] && source="$upstream"
    fi

    # Check for scripts
    if [[ -d "$skill_dir/scripts" ]] && ls "$skill_dir/scripts"/* &>/dev/null 2>&1; then
      has_script="yes"
    fi

    printf "%-40s %-10s %-6s %-20s\n" "$name" "$skill_type" "$has_script" "$source"
  done
}

_list_json() {
  local first=true
  echo "["
  for skill_dir in "$SKILLS_DIR"/*/; do
    [[ -d "$skill_dir" ]] || continue
    local name
    name=$(basename "$skill_dir")
    [[ "$name" == _* || "$name" == .* ]] && continue

    local skill_type="original" has_script=false source=""

    if [[ -f "$MANIFEST" ]] && command -v jq &>/dev/null; then
      skill_type=$(jq -r ".skills[\"$name\"].type // \"unknown\"" "$MANIFEST" 2>/dev/null)
      source=$(jq -r ".skills[\"$name\"].upstream // empty" "$MANIFEST" 2>/dev/null)
    fi

    if [[ -d "$skill_dir/scripts" ]] && ls "$skill_dir/scripts"/* &>/dev/null 2>&1; then
      has_script=true
    fi

    [[ "$first" == true ]] && first=false || echo ","
    printf '  {"name":"%s","type":"%s","hasScript":%s,"source":"%s"}' \
      "$name" "$skill_type" "$has_script" "$source"
  done
  echo ""
  echo "]"
}

cmd_validate() {
  local target="" errors=0 warnings=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help) cat <<'EOF'
Usage: skill-manager validate [<name-or-path>]

Validate skill conventions. Validates all skills if no name given.
Accepts a skill name (looked up in skills/) or a directory path.

Checks:
  - Directory name is kebab-case
  - SKILL.md exists with valid frontmatter
  - Name: max 64 chars, no consecutive hyphens
  - Description: max 1024 chars, starts with "Use when"
  - Frontmatter under 1024 chars
  - Body under 500 lines (warn)
  - Scripts: executable, correct shebang, --help support
  - No cross-skill relative paths (../../)
  - No hardcoded ~/.agents/ paths

Exit codes:
  0  All checks pass
  1  Errors found
  2  Warnings only
EOF
        exit 0 ;;
      -*) die "Unknown option: $1" ;;
      *) target="$1"; shift ;;
    esac
  done

  if [[ -n "$target" ]]; then
    local dir
    if [[ -d "$target" ]]; then
      dir="$target"
    elif skill_exists "$target"; then
      dir="$SKILLS_DIR/$target"
    else
      die "Skill not found: $target"
    fi
    _validate_skill_dir "$dir"
    errors=$?
  else
    for skill_dir in "$SKILLS_DIR"/*/; do
      [[ -d "$skill_dir" ]] || continue
      [[ "$(basename "$skill_dir")" == _* || "$(basename "$skill_dir")" == .* ]] && continue
      local result=0
      _validate_skill_dir "$skill_dir" || result=$?
      if [[ $result -eq 1 ]]; then
        errors=$((errors + 1))
      elif [[ $result -eq 2 ]]; then
        warnings=$((warnings + 1))
      fi
    done
  fi

  if [[ $errors -gt 0 ]]; then
    echo "$errors skill(s) with errors, $warnings with warnings" >&2
    exit 1
  elif [[ $warnings -gt 0 ]]; then
    echo "All skills valid, $warnings warning(s)" >&2
    exit 2
  else
    echo "All skills valid" >&2
    exit 0
  fi
}

_validate_skill_dir() {
  local dir="${1%/}"
  local name
  name=$(basename "$dir")
  local has_error=false has_warning=false

  # ── Directory name checks ──
  if ! is_kebab_case "$name"; then
    echo "ERROR [$name]: directory name not kebab-case" >&2
    has_error=true
  fi

  if [[ ${#name} -gt 64 ]]; then
    echo "ERROR [$name]: name exceeds 64 characters (${#name})" >&2
    has_error=true
  fi

  if [[ "$name" == *--* ]]; then
    echo "ERROR [$name]: name contains consecutive hyphens" >&2
    has_error=true
  fi

  # ── SKILL.md existence ──
  if [[ ! -f "$dir/SKILL.md" ]]; then
    echo "ERROR [$name]: SKILL.md not found" >&2
    return 1
  fi

  # ── Parse frontmatter ──
  local frontmatter=""
  if head -1 "$dir/SKILL.md" | grep -q "^---"; then
    frontmatter=$(sed -n '2,/^---$/p' "$dir/SKILL.md" | sed '$d')
  fi

  if [[ -z "$frontmatter" ]]; then
    echo "ERROR [$name]: no YAML frontmatter found" >&2
    has_error=true
  else
    # Frontmatter size
    local fm_size
    fm_size=$(printf '%s' "$frontmatter" | wc -c | tr -d ' ')
    if [[ $fm_size -gt 1024 ]]; then
      echo "WARN  [$name]: frontmatter exceeds 1024 chars ($fm_size)" >&2
      has_warning=true
    fi

    # Name field
    local fm_name
    fm_name=$(echo "$frontmatter" | grep "^name:" | sed 's/^name:[[:space:]]*//')
    if [[ -z "$fm_name" ]]; then
      echo "ERROR [$name]: frontmatter missing 'name' field" >&2
      has_error=true
    else
      if [[ "$fm_name" != "$name" ]]; then
        echo "WARN  [$name]: frontmatter name '$fm_name' doesn't match directory '$name'" >&2
        has_warning=true
      fi
      if ! [[ "$fm_name" =~ ^[a-z0-9]([a-z0-9-]*[a-z0-9])?$ ]]; then
        echo "ERROR [$name]: name field not valid kebab-case" >&2
        has_error=true
      fi
      if [[ ${#fm_name} -gt 64 ]]; then
        echo "ERROR [$name]: name field exceeds 64 characters (${#fm_name})" >&2
        has_error=true
      fi
      if [[ "$fm_name" == *--* ]]; then
        echo "ERROR [$name]: name field contains consecutive hyphens" >&2
        has_error=true
      fi
    fi

    # Description field
    local fm_desc
    fm_desc=$(echo "$frontmatter" | grep "^description:" | sed 's/^description:[[:space:]]*//')
    if [[ -z "$fm_desc" ]]; then
      echo "ERROR [$name]: frontmatter missing 'description' field" >&2
      has_error=true
    else
      if ! echo "$fm_desc" | grep -qi "^use when"; then
        echo "WARN  [$name]: description should start with 'Use when'" >&2
        has_warning=true
      fi
      if [[ ${#fm_desc} -gt 1024 ]]; then
        echo "WARN  [$name]: description exceeds 1024 characters (${#fm_desc})" >&2
        has_warning=true
      fi
    fi
  fi

  # ── Body length check ──
  local body_start
  body_start=$(awk '/^---$/{n++; if(n==2){print NR; exit}}' "$dir/SKILL.md")
  if [[ -n "$body_start" ]]; then
    local total_lines body_lines
    total_lines=$(wc -l < "$dir/SKILL.md" | tr -d ' ')
    body_lines=$((total_lines - body_start))
    if [[ $body_lines -gt 500 ]]; then
      echo "WARN  [$name]: body is $body_lines lines (target under 500)" >&2
      has_warning=true
    fi
  fi

  # ── Script convention checks ──
  if [[ -d "$dir/scripts" ]]; then
    for script in "$dir/scripts"/*; do
      [[ -f "$script" ]] || continue
      local sname
      sname=$(basename "$script")

      if [[ ! -x "$script" ]]; then
        echo "WARN  [$name]: script '$sname' is not executable" >&2
        has_warning=true
      fi

      # Shebang check
      local shebang
      shebang=$(head -1 "$script")
      if [[ "$shebang" != "#!/usr/bin/env bash" ]]; then
        echo "WARN  [$name]: script '$sname' missing '#!/usr/bin/env bash' shebang" >&2
        has_warning=true
      fi

      # --help support check (only if executable)
      if [[ -x "$script" ]]; then
        if ! "$script" --help &>/dev/null; then
          echo "WARN  [$name]: script '$sname' does not support --help" >&2
          has_warning=true
        fi
      fi
    done
  fi

  # ── Content checks ──
  if grep -r '\.\./\.\.' "$dir" --include="*.md" -l 2>/dev/null | grep -q .; then
    echo "WARN  [$name]: contains cross-skill relative paths (../../)" >&2
    has_warning=true
  fi

  if grep -r "$HOME/.agents/" "$dir" --include="*.md" -l 2>/dev/null | grep -q .; then
    echo "WARN  [$name]: contains hardcoded ~/.agents/ paths" >&2
    has_warning=true
  fi

  if [[ "$has_error" == true ]]; then
    return 1
  elif [[ "$has_warning" == true ]]; then
    return 2
  fi
  return 0
}

# ── Main ──────────────────────────────────────────────────────────

[[ $# -gt 0 ]] || { usage; exit 1; }

case "$1" in
  create)   shift; cmd_create "$@" ;;
  install)  shift; cmd_install "$@" ;;
  remove)   shift; cmd_remove "$@" ;;
  list)     shift; cmd_list "$@" ;;
  validate) shift; cmd_validate "$@" ;;
  --help)   usage; exit 0 ;;
  *)        die "Unknown command: $1. Run 'skill-manager --help' for usage." ;;
esac
