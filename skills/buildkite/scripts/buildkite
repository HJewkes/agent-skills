#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ENV_FILE="${BUILDKITE_ENV_FILE:-${HOME}/.buildkite-env}"

# --- Triage subcommand ---

triage_usage() {
  cat <<'EOF'
Usage: buildkite triage <pipeline-slug> [options]

Fetch failed builds, download logs, and categorize failures by pattern.

Options:
  --build <number>   Triage a specific build number
  --last <N>         Number of recent failed builds to triage (default: 1)
  --help, -h         Show this help message

Examples:
  buildkite triage my-pipeline
  buildkite triage my-pipeline --build 456
  buildkite triage my-pipeline --last 5
EOF
}

categorize_log() {
  local log="$1"
  local category="Unknown"
  local key_line=""

  local categories patterns
  categories=(
    "Test Failure"
    "Flaky Tests"
    "Dependency"
    "Timeout"
    "OOM"
    "Auth/Permission"
    "Infrastructure"
  )
  patterns=(
    'FAIL|FAILED|AssertionError|Expected.*got'
    'passed on retry|retry.*passed|intermittent|flaky|timing.dependent'
    'ERR!|could not resolve|not found'
    'timed out|exceeded.*time|terminated'
    'Killed|OOMKilled|signal.*killed'
    '403|401|forbidden|unauthorized|permission denied'
    'docker.*pull.*failed|agent disconnected|network'
  )

  for i in "${!categories[@]}"; do
    key_line=$(grep -iE "${patterns[$i]}" <<< "$log" | head -1 || true)
    if [[ -n "$key_line" ]]; then
      category="${categories[$i]}"
      break
    fi
  done

  printf '%s\t%s\n' "$category" "$key_line"
}

triage_build() {
  local pipeline="$1"
  local build_number="$2"

  local job_lines
  job_lines=$(bk job list --build "$build_number" --pipeline "$pipeline" --state failed 2>/dev/null || true)

  if [[ -z "$job_lines" ]]; then
    echo "No failed jobs found for build #${build_number}."
    return
  fi

  echo "## Build Triage: ${pipeline} #${build_number}"
  echo ""
  echo "| Job | Category | Key Line |"
  echo "|-----|----------|----------|"

  local summary_keys=()
  local summary_vals=()

  while IFS= read -r job_id; do
    [[ -z "$job_id" ]] && continue

    local job_name
    job_name=$(bk job view "$job_id" --pipeline "$pipeline" --build "$build_number" 2>/dev/null | head -1 || echo "$job_id")

    local log
    log=$(bk job log "$job_id" 2>/dev/null || echo "")

    local result
    result=$(categorize_log "$log")
    local category key_line
    category=$(cut -f1 <<< "$result")
    key_line=$(cut -f2- <<< "$result")

    # Truncate key line for table display
    if [[ ${#key_line} -gt 80 ]]; then
      key_line="${key_line:0:77}..."
    fi

    echo "| ${job_name} | ${category} | ${key_line} |"

    # Track counts using parallel arrays (bash 3.2 compatible)
    local found=0
    for idx in "${!summary_keys[@]}"; do
      if [[ "${summary_keys[$idx]}" == "$category" ]]; then
        summary_vals[idx]=$(( summary_vals[idx] + 1 ))
        found=1
        break
      fi
    done
    if [[ "$found" -eq 0 ]]; then
      summary_keys+=("$category")
      summary_vals+=("1")
    fi
  done <<< "$job_lines"

  echo ""
  local summary_parts=()
  for idx in "${!summary_keys[@]}"; do
    local count="${summary_vals[$idx]}"
    local label
    label=$(tr '[:upper:]' '[:lower:]' <<< "${summary_keys[$idx]}")
    if [[ "$count" -eq 1 ]]; then
      summary_parts+=("${count} ${label}")
    else
      summary_parts+=("${count} ${label}s")
    fi
  done

  local joined
  joined=$(IFS=', '; echo "${summary_parts[*]}")
  echo "**Summary: ${joined}**"
}

run_triage() {
  if [[ $# -eq 0 ]]; then
    echo "Error: missing required argument <pipeline-slug>" >&2
    echo "Run 'buildkite triage --help' for usage." >&2
    exit 1
  fi

  if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    triage_usage
    exit 0
  fi

  local pipeline="$1"
  shift

  local build_number=""
  local last_n=1

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --build)
        build_number="${2:-}"
        [[ -z "$build_number" ]] && { echo "Error: --build requires a value" >&2; exit 1; }
        shift 2
        ;;
      --last)
        last_n="${2:-}"
        [[ -z "$last_n" ]] && { echo "Error: --last requires a value" >&2; exit 1; }
        shift 2
        ;;
      --help|-h)
        triage_usage
        exit 0
        ;;
      *)
        echo "Error: unknown option '$1'" >&2
        triage_usage >&2
        exit 1
        ;;
    esac
  done

  if [[ -n "$build_number" ]]; then
    triage_build "$pipeline" "$build_number"
  else
    local builds
    builds=$(bk build list --pipeline "$pipeline" --state failed --count "$last_n" 2>/dev/null || true)

    if [[ -z "$builds" ]]; then
      echo "No failed builds found for pipeline '${pipeline}'."
      exit 0
    fi

    while IFS= read -r build_num; do
      [[ -z "$build_num" ]] && continue
      triage_build "$pipeline" "$build_num"
      echo ""
    done <<< "$builds"
  fi
}

# --- Intercept triage before passthrough ---

if [[ "${1:-}" == "triage" ]]; then
  shift

  # Ensure setup before triage (unless help/no-args which don't need bk)
  if [[ $# -gt 0 && "${1:-}" != "--help" && "${1:-}" != "-h" ]]; then
    if ! command -v bk >/dev/null 2>&1; then
      echo "Error: 'bk' CLI is not installed or not in PATH." >&2
      echo "Install it from https://github.com/buildkite/cli and try again." >&2
      exit 1
    fi
    if [[ ! -f "$ENV_FILE" ]]; then
      echo "First run detected — launching setup..." >&2
      "$SCRIPT_DIR/setup"
      [[ -f "$ENV_FILE" ]] || { echo "Setup did not complete. Run: $SCRIPT_DIR/setup" >&2; exit 1; }
    fi
    # shellcheck source=/dev/null
    source "$ENV_FILE"
  fi

  run_triage "$@"
  exit $?
fi

# --- Extended help (includes triage subcommand) ---

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  cat <<'HELPEOF'
Usage: buildkite <command> [options]

Wrapper around the Buildkite CLI (bk) with additional subcommands.

Additional subcommands:
  triage <pipeline-slug>   Fetch failed builds and categorize failures

All other commands are passed through to `bk`. Run `bk --help` for
the full list of built-in commands.

Run `buildkite triage --help` for triage-specific usage.
HELPEOF
  exit 0
fi

# --- Ensure setup ---

if [[ ! -f "$ENV_FILE" ]]; then
  echo "First run detected — launching setup..." >&2
  "$SCRIPT_DIR/setup"
  [[ -f "$ENV_FILE" ]] || { echo "Setup did not complete. Run: $SCRIPT_DIR/setup" >&2; exit 1; }
fi

# shellcheck source=/dev/null
source "$ENV_FILE"

exec bk "$@"
