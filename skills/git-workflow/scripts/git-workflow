#!/usr/bin/env bash
set -euo pipefail

# Color helpers
if [[ -t 1 ]] && command -v tput &>/dev/null; then
  RED=$(tput setaf 1)
  GREEN=$(tput setaf 2)
  YELLOW=$(tput setaf 3)
  CYAN=$(tput setaf 6)
  BOLD=$(tput bold)
  RESET=$(tput sgr0)
else
  RED="" GREEN="" YELLOW="" CYAN="" BOLD="" RESET=""
fi

die() { echo "${RED}Error: $1${RESET}" >&2; exit 1; }
info() { echo "${CYAN}$1${RESET}" >&2; }
warn() { echo "${YELLOW}Warning: $1${RESET}" >&2; }

# --- Tool detection ---

detect_tool() {
  if command -v gt &>/dev/null; then
    echo "graphite"
  elif command -v git &>/dev/null; then
    echo "git"
  else
    echo "none"
  fi
}

detect_trunk() {
  local remote="${1:-origin}"
  if git rev-parse --verify "$remote/main" &>/dev/null; then
    echo "main"
  elif git rev-parse --verify "$remote/master" &>/dev/null; then
    echo "master"
  else
    git remote show "$remote" 2>/dev/null | awk '/HEAD branch/{print $NF}' || echo "main"
  fi
}

# --- Usage ---

usage() {
  cat <<'EOF'
Usage: git-workflow <command> [options]

Commands:
  status     Detect environment and report repo state (default)
  commit     Guided commit with conventional format
  split      Analyze and decompose large diffs
  stack      View and manage branch stack
  worktree   Create isolated worktree
  clean      Remove merged/gone branches

Options:
  --help     Show this help message

Run 'git-workflow <command> --help' for command-specific options.

Exit codes:
  0  Success
  1  Error
  2  Warnings
EOF
}

# --- Status subcommand ---

usage_status() {
  cat <<'EOF'
Usage: git-workflow status [options]

Detect git tool (Graphite or Git) and report repository state.

Options:
  --json     Output as JSON
  --help     Show this help message

Output includes:
  - Detected tool (graphite or git) and version
  - Current branch
  - Dirty file count (staged + unstaged)
  - Ahead/behind counts relative to remote
  - Stack state (Graphite only)
EOF
}

cmd_status() {
  local json_output=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) json_output=true; shift ;;
      --help) usage_status; exit 0 ;;
      *) die "Unknown option for status: $1" ;;
    esac
  done

  # Must be in a git repo
  git rev-parse --git-dir &>/dev/null || die "not a git repository"

  local tool
  tool=$(detect_tool)
  [[ "$tool" == "none" ]] && die "neither git nor gt found"

  local tool_version=""
  if [[ "$tool" == "graphite" ]]; then
    tool_version=$(gt --version 2>/dev/null || echo "unknown")
  else
    tool_version=$(git --version 2>/dev/null | awk '{print $3}')
  fi

  local branch
  branch=$(git branch --show-current 2>/dev/null || echo "detached")

  local trunk
  trunk=$(detect_trunk)

  # Dirty files
  local staged unstaged
  staged=$(git diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
  unstaged=$(git diff --numstat 2>/dev/null | wc -l | tr -d ' ')
  local untracked
  untracked=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

  # Ahead/behind
  local ahead=0 behind=0
  if git rev-parse --verify "origin/$branch" &>/dev/null; then
    ahead=$(git rev-list --count "origin/$branch..HEAD" 2>/dev/null || echo 0)
    behind=$(git rev-list --count "HEAD..origin/$branch" 2>/dev/null || echo 0)
  fi

  # Stack state (Graphite only)
  local stack_info=""
  if [[ "$tool" == "graphite" ]]; then
    stack_info=$(gt log short 2>/dev/null || echo "no stack")
  fi

  if [[ "$json_output" == true ]]; then
    cat <<ENDJSON
{
  "tool": "$tool",
  "toolVersion": "$tool_version",
  "branch": "$branch",
  "trunk": "$trunk",
  "staged": $staged,
  "unstaged": $unstaged,
  "untracked": $untracked,
  "ahead": $ahead,
  "behind": $behind
}
ENDJSON
  else
    echo "${BOLD}Git Workflow Status${RESET}"
    echo ""
    echo "  Tool:      ${GREEN}$tool${RESET} ($tool_version)"
    echo "  Branch:    ${CYAN}$branch${RESET}"
    echo "  Trunk:     $trunk"
    echo "  Staged:    $staged files"
    echo "  Unstaged:  $unstaged files"
    echo "  Untracked: $untracked files"
    echo "  Ahead:     $ahead commits"
    echo "  Behind:    $behind commits"
    if [[ -n "$stack_info" && "$stack_info" != "no stack" ]]; then
      echo ""
      echo "  ${BOLD}Stack:${RESET}"
      echo "    ${stack_info//$'\n'/$'\n'    }"
    fi
  fi
}

# --- Commit subcommand ---

usage_commit() {
  cat <<'EOF'
Usage: git-workflow commit [options]

Guided commit with conventional format.

Options:
  -m, --message <msg>  Commit message (conventional format: "type: description")
  -a, --all            Stage all modified files before committing
  --amend              Amend the current branch commit (gt modify or git commit --amend)
  --help               Show this help message

Behavior:
  - Graphite: uses 'gt create' for new branch+commit, 'gt modify' for amend
  - Git: uses 'git commit', 'git commit --amend' for amend
  - Validates message matches conventional format before committing
  - Shows staged files summary before executing
EOF
}

cmd_commit() {
  local message="" stage_all=false amend=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -m|--message) message="$2"; shift 2 ;;
      -a|--all) stage_all=true; shift ;;
      --amend) amend=true; shift ;;
      --help) usage_commit; exit 0 ;;
      *) die "Unknown option for commit: $1" ;;
    esac
  done

  git rev-parse --git-dir &>/dev/null || die "not a git repository"

  local tool
  tool=$(detect_tool)

  # Stage all if requested
  if [[ "$stage_all" == true ]]; then
    git add -u
    info "Staged all modified tracked files"
  fi

  # Check for staged changes
  local staged_count
  staged_count=$(git diff --cached --numstat 2>/dev/null | wc -l | tr -d ' ')
  if [[ "$staged_count" -eq 0 && "$amend" == false ]]; then
    die "no staged changes. Stage files first with 'git add <file>'"
  fi

  # Require message
  [[ -z "$message" ]] && die "commit message required. Use -m 'type: description'"

  # Validate conventional commit format
  if ! echo "$message" | grep -qE '^(feat|fix|docs|refactor|perf|test|chore|ci|style)(\(.+\))?!?: .+'; then
    warn "message does not match conventional format: type[(scope)][!]: description"
    warn "valid types: feat, fix, docs, refactor, perf, test, chore, ci, style"
  fi

  # Show what will be committed
  echo "${BOLD}Staged changes:${RESET}"
  git diff --cached --stat
  echo ""

  if [[ "$amend" == true ]]; then
    if [[ "$tool" == "graphite" ]]; then
      info "Amending with: gt modify"
      gt modify -m "$message"
    else
      info "Amending with: git commit --amend"
      git commit --amend -m "$message"
    fi
  else
    if [[ "$tool" == "graphite" ]]; then
      info "Creating with: gt create -m '$message'"
      gt create -m "$message"
    else
      info "Committing with: git commit"
      git commit -m "$message"
    fi
  fi

  echo ""
  echo "${GREEN}Done.${RESET}"
}

# --- Clean subcommand ---

usage_clean() {
  cat <<'EOF'
Usage: git-workflow clean [options]

Remove branches that have been merged or deleted on the remote.

Options:
  --dry-run    Show what would be removed without doing it
  --help       Show this help message

Behavior:
  - Graphite: runs 'gt sync' which handles cleanup
  - Git: finds [gone] branches, removes associated worktrees, deletes branches
EOF
}

cmd_clean() {
  local dry_run=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run) dry_run=true; shift ;;
      --help) usage_clean; exit 0 ;;
      *) die "Unknown option for clean: $1" ;;
    esac
  done

  git rev-parse --git-dir &>/dev/null || die "not a git repository"

  local tool
  tool=$(detect_tool)

  # Fetch latest remote state
  info "Fetching remote..."
  git fetch --prune 2>/dev/null

  if [[ "$tool" == "graphite" ]]; then
    if [[ "$dry_run" == true ]]; then
      info "Dry run: would run 'gt sync' to clean up merged branches"
      gt log short 2>/dev/null || true
    else
      info "Running: gt sync"
      gt sync
    fi
    return
  fi

  # Git: find gone branches
  local gone_branches
  gone_branches=$(git branch -v 2>/dev/null | grep '\[gone\]' | sed 's/^[+* ]*//' | awk '{print $1}') || true

  if [[ -z "$gone_branches" ]]; then
    echo "No stale branches found."
    return
  fi

  echo "${BOLD}Stale branches:${RESET}"
  echo "$gone_branches" | while read -r branch; do
    echo "  - $branch"
  done

  if [[ "$dry_run" == true ]]; then
    echo ""
    echo "(dry run â€” no changes made)"
    return
  fi

  echo ""
  echo "$gone_branches" | while read -r branch; do
    # Remove associated worktree if exists
    local worktree_path
    worktree_path=$(git worktree list 2>/dev/null | grep "\\[$branch\\]" | awk '{print $1}')
    if [[ -n "$worktree_path" && "$worktree_path" != "$(git rev-parse --show-toplevel)" ]]; then
      info "Removing worktree: $worktree_path"
      git worktree remove --force "$worktree_path" 2>/dev/null || warn "failed to remove worktree $worktree_path"
    fi

    info "Deleting branch: $branch"
    git branch -D "$branch" 2>/dev/null || warn "failed to delete branch $branch"
  done

  echo ""
  echo "${GREEN}Cleanup complete.${RESET}"
}

# --- Subcommand routing ---

COMMAND="${1:-status}"
shift 2>/dev/null || true

case "$COMMAND" in
  status)   cmd_status "$@" ;;
  commit)   cmd_commit "$@" ;;
  split)    die "split subcommand not yet implemented" ;;
  stack)    die "stack subcommand not yet implemented" ;;
  worktree) die "worktree subcommand not yet implemented" ;;
  clean)    cmd_clean "$@" ;;
  --help|-h) usage; exit 0 ;;
  *)        die "Unknown command: $COMMAND. Run 'git-workflow --help' for usage." ;;
esac
